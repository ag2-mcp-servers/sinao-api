# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:23:02+00:00



import argparse
import json
import os
from datetime import date as date_aliased
from datetime import datetime
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBasic, HTTPBearer
from fastapi import Path, Query
from pydantic import EmailStr, conint, constr

from models import (
    AccessInvitation,
    Account,
    AccountCategory,
    AccountType,
    Amounts,
    ApiResponse,
    App,
    AppsAppIdAccessGetResponse,
    AppsAppIdAccessInviteGetResponse,
    AppsAppIdAccessProfilesGetResponse,
    AppsAppIdAccountcategoriesGetResponse,
    AppsAppIdAccountingEntriesGetResponse,
    AppsAppIdAccountsGetResponse,
    AppsAppIdApikeysGetResponse,
    AppsAppIdApipartnersGetResponse,
    AppsAppIdAttachmentsGetResponse,
    AppsAppIdBankdetailsGetResponse,
    AppsAppIdBanksConnectGetResponse,
    AppsAppIdBanksDeleteResponse,
    AppsAppIdBanksGetResponse,
    AppsAppIdBanksIdFunnelEditGetResponse,
    AppsAppIdBanksIdFunnelSyncGetResponse,
    AppsAppIdBanksIdFunnelValidateGetResponse,
    AppsAppIdCashflowsourcesGetResponse,
    AppsAppIdExportsAcdComptaGetResponse,
    AppsAppIdExportsAcdComptaPostResponse,
    AppsAppIdExportsGetResponse,
    AppsAppIdExportsMonthsGetResponse,
    AppsAppIdInvoicesFreshPostResponse,
    AppsAppIdInvoicesGetResponse,
    AppsAppIdInvoicesStatisticsGetResponse,
    AppsAppIdOrganizationGetResponse,
    AppsAppIdOrganizationsGetResponse,
    AppsAppIdPaymentsGetResponse,
    AppsAppIdPersonsGetResponse,
    AppsAppIdProductcategoryGetResponse,
    AppsAppIdProductsGetResponse,
    AppsAppIdProductstocksGetResponse,
    AppsAppIdPurchasesGetResponse,
    AppsAppIdPurchasesStatisticsGetResponse,
    AppsAppIdQuotesFreshPostResponse,
    AppsAppIdQuotesGetResponse,
    AppsAppIdQuotesStatisticsGetResponse,
    AppsAppIdRecurringinvoicesGetResponse,
    AppsAppIdRecurringinvoicesIdPlanGetResponse,
    AppsAppIdRecurringinvoicesPeriodsGetResponse,
    AppsAppIdRelationshipsGetResponse,
    AppsAppIdRulesGetResponse,
    AppsAppIdSalesdocumentmodelsGetResponse,
    AppsAppIdSepamandatesCredittransferGetResponse,
    AppsAppIdSepamandatesDirectdebitGetResponse,
    AppsAppIdSepamandatesGetResponse,
    AppsAppIdSettingsGetResponse,
    AppsAppIdStatisticsChartsTypeGetResponse,
    AppsAppIdStatisticsTimetablePurchasesGetResponse,
    AppsAppIdStatisticsTimetableSalesGetResponse,
    AppsAppIdStatisticsVatGetResponse,
    AppsAppIdSubscriptionPlanGetResponse,
    AppsAppIdSubscriptionPlansGetResponse,
    AppsAppIdTagsGetResponse,
    AppsAppIdTransactionsGetResponse,
    AppsAppIdUrssafPaymentGetResponse,
    AppsAppIdUrssafPreviewGetResponse,
    AppsGetResponse,
    BankAccountIds,
    BankDetails,
    Calcul,
    CashflowSource,
    Columns,
    Conditions,
    ContactInfos2,
    ContactInfos4,
    ContactInfos6,
    ContactInfos8,
    ContactInfos10,
    ContactInfos12,
    ContactOrganization,
    ContactPerson,
    Contacts,
    Content,
    Content4,
    Content6,
    Data,
    Data1,
    Data2,
    Data3,
    Data4,
    Data5,
    Data6,
    Data7,
    Data8,
    Data9,
    Data10,
    Discount2,
    DiscountMode,
    Documents,
    DownpaymentRequest1,
    Downpayments,
    Emails,
    EstablishmentIdentity,
    ExcludeKeys,
    Expand,
    ExportEntitiesIds,
    ExportEntity,
    Filters,
    Filters1,
    Filters2,
    Filters3,
    Filters4,
    Filters5,
    Filters6,
    Filters7,
    Filters8,
    Filters9,
    Filters10,
    Filters11,
    Filters12,
    Filters13,
    Filters14,
    Filters15,
    Filters16,
    Filters17,
    Filters18,
    Filters19,
    Filters20,
    Filters21,
    Filters22,
    Filters23,
    Filters24,
    Filters25,
    Filters26,
    Filters27,
    Filters28,
    Filters29,
    Filters30,
    Filters31,
    Format,
    FrequencyDuration,
    GroupBy,
    Groups,
    Ids,
    Image,
    Invoice,
    InvoicesIds,
    JsonWebToken,
    Logo,
    Messages,
    Metadata,
    Method,
    Methods,
    Movements1,
    Object,
    Object2,
    Order,
    Order1,
    Order2,
    Order3,
    Order4,
    Order5,
    Order6,
    Order7,
    Order8,
    Order9,
    Order10,
    Order11,
    Order12,
    Order13,
    Order14,
    Order15,
    Order16,
    Order17,
    Order18,
    Order19,
    Order20,
    Order21,
    Order22,
    Order23,
    Order24,
    Order25,
    Order26,
    Order27,
    OrdersPlan,
    OrdersPlan1,
    Payment,
    Period,
    Period2,
    Phones,
    Picture,
    Place1,
    PolicyProfile,
    Product,
    ProductCategory,
    ProductStock,
    Purchase,
    PurchaseLines,
    Quote,
    Recipients,
    RecipientsBcc,
    RecipientsCc,
    RecurringInvoice,
    Relationship,
    Rule,
    Rule1,
    SalesDocumentModel,
    SEPAMandate,
    Settings,
    SinaoOrganization,
    Status3,
    Status5,
    Status7,
    Tags,
    Tags2,
    Tags8,
    Template,
    ThirdAccount2,
    ThirdAccount4,
    ThirdAccount6,
    ThirdAccount8,
    Transaction,
    Type6,
    Type8,
    Type12,
    Type30,
    Type42,
    Type46,
    Type52,
    User,
    VatDetail,
    VatExemption1,
    VatExemption5,
    VatRepayment,
)

app = MCPProxy(
    contact={'email': 'contact@sinao.fr'},
    description='Sinao API for account management, apps administration and network exploration',
    license={
        'name': 'Apache 2.0',
        'url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
    },
    title='Sinao API',
    version='1.1.0',
    servers=[
        {'description': 'Production', 'url': 'https://api.sinao.app/v1'},
        {'description': 'Staging', 'url': 'https://api.sinao.dev/v1'},
        {'description': 'Development', 'url': 'https://api.sinao.test/v1'},
    ],
)


@app.get(
    '/apps', description=""" Get all apps """, tags=['app_management'], security=[]
)
def app_list(
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters] = None,
    order: Optional[Order] = None,
):
    """
    List apps
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps',
    description=""" Create a new `App` with their organization profile """,
    tags=['app_management', 'organization_profile_management'],
    security=[],
)
def app_create(organization_name: constr(pattern=r'/^.*[a-z]+.*$/i')):
    """
    Create an app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/access/invite/{accessToken}',
    description=""" Remove an invitation from token """,
    tags=['app_invitations_management'],
)
def app_policies_registration_delete(
    access_token: str = Path(..., alias='accessToken')
):
    """
    Delete an invitation from token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/access/invite/{accessToken}',
    description=""" Get infos of an invitation request. Returns an `AccessInvitation` object """,
    tags=['app_invitations_management'],
)
def app_policies_registration_get(access_token: str = Path(..., alias='accessToken')):
    """
    Get invitation informations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/access/invite/{accessToken}/register',
    description=""" Registration for an invited user """,
    tags=['app_invitations_management', 'user_account_management'],
    security=[],
)
def app_policies_registration_register(
    access_token: str = Path(..., alias='accessToken'),
    password: str = ...,
    firstname: Optional[str] = None,
    lastname: Optional[str] = None,
    cgu: bool = ...,
):
    """
    Create an User by invitation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}',
    description=""" Get app informations """,
    tags=['app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_get(app_id: int = Path(..., alias='appId')):
    """
    Get an app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/access',
    description=""" Get all policies for an app. Manage access for users """,
    tags=['app_policies_management'],
    security=[],
)
def app_policies_list(
    app_id: int = Path(..., alias='appId'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters1] = None,
    order: Optional[Order1] = None,
):
    """
    Get policies for an app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/access/invite',
    description=""" Get all sent invitations """,
    tags=['app_invitations_management'],
    security=[],
)
def app_policies_invitations_list(
    app_id: int = Path(..., alias='appId'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters2] = None,
    order: Optional[Order2] = None,
):
    """
    List invitations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/access/invite',
    description=""" Invites a user to access the organization panel """,
    tags=['app_invitations_management', 'user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_policies_invitations_create(
    app_id: int = Path(..., alias='appId'),
    email: str = ...,
    policy_profile_id: conint(ge=0) = ...,
    firstname: Optional[str] = None,
    lastname: Optional[str] = None,
    civility: Optional[str] = None,
    password: Optional[str] = None,
):
    """
    Invite an user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/access/invite/{id}',
    description=""" Remove an invitation """,
    tags=['app_invitations_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_policies_invitations_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Delete an invitation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/access/profiles',
    description=""" Get all profiles """,
    tags=['app_management', 'organization_profile_management'],
    security=[],
)
def app_policies_profiles_list(app_id: int = Path(..., alias='appId')):
    """
    Get profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/access/{userId}',
    description=""" Cancel access for an user on an app """,
    tags=['app_policies_management', 'user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_policies_delete(
    app_id: int = Path(..., alias='appId'), user_id: str = Path(..., alias='userId')
):
    """
    Delete police for an user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/access/{userId}',
    description=""" Find policy profile for an user on an app """,
    tags=['app_policies_management', 'user_account_management'],
    security=[],
)
def app_policies_get(
    app_id: int = Path(..., alias='appId'), user_id: str = Path(..., alias='userId')
):
    """
    Get police for an user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/access/{userId}',
    description=""" Update police for an user on an app """,
    tags=['app_policies_management', 'user_account_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_policies_update(
    app_id: int = Path(..., alias='appId'),
    user_id: str = Path(..., alias='userId'),
    policy_profile_id: conint(ge=0) = ...,
):
    """
    Update police for an user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/accountcategories/',
    tags=['app_management', 'catalog_categories_management'],
    security=[],
)
def app_accounting_categories_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters3] = None,
    order: Optional[Order3] = None,
):
    """
    List categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/accountcategories/',
    tags=['app_accounting_categories_management'],
    security=[],
)
def app_accounting_categories_create(
    app_id: int = Path(..., alias='appId'),
    name: Optional[str] = None,
    description: Optional[str] = None,
    type: Optional[str] = None,
):
    """
    Create a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/accountcategories/{id}',
    tags=['app_accounting_categories_management'],
    security=[],
)
def app_accounting_categories_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/accountcategories/{id}',
    tags=['app_policies_management', 'app_accounting_categories_management'],
    security=[],
)
def app_accounting_categories_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/accountcategories/{id}',
    tags=['app_accounting_categories_management', 'catalog_categories_management'],
    security=[],
)
def app_accounting_categories_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: Optional[str] = None,
    description: Optional[str] = None,
    type: Optional[str] = None,
):
    """
    Update a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/accounting_entries/',
    tags=['app_accounting_entries_management'],
    security=[],
)
def app_accounting_entries_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters4] = None,
    order: Optional[Order4] = None,
):
    """
    List accounting entries
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/accounts/',
    tags=['app_management', 'user_account_management'],
    security=[],
)
def app_accounting_accounts_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters5] = None,
    order: Optional[Order5] = None,
):
    """
    List Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/accounts/',
    tags=[
        'app_accounting_accounts_management',
        'app_bank_details_management',
        'app_cashflow_management',
    ],
    security=[],
)
def app_accounting_accounts_create(
    app_id: int = Path(..., alias='appId'),
    journalcode: Optional[str] = None,
    name: Optional[str] = None,
    description: Optional[str] = None,
    keywords: Optional[str] = None,
    accounting_number: Optional[str] = None,
    is_cashflow: Optional[bool] = None,
    is_sales: Optional[bool] = None,
    is_purchase: Optional[bool] = None,
):
    """
    Create a Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/accounts/batch',
    description=""" Create many accounts """,
    tags=['user_account_management'],
    security=[],
)
def app_accounting_accounts_batch(
    app_id: int = Path(..., alias='appId'), data: Data = ...
):
    """
    Create many accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/accounts/{id}', tags=['user_account_management'], security=[]
)
def app_accounting_accounts_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/accounts/{id}', tags=['user_account_management'], security=[])
def app_accounting_accounts_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/accounts/{id}',
    tags=['app_accounting_accounts_management', 'app_accounting_categories_management'],
    security=[],
)
def app_accounting_accounts_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    journalcode: Optional[str] = None,
    name: Optional[str] = None,
    description: Optional[str] = None,
    keywords: Optional[str] = None,
    accounting_number: Optional[str] = None,
    is_cashflow: Optional[bool] = None,
    is_sales: Optional[bool] = None,
    is_purchase: Optional[bool] = None,
):
    """
    Update a Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/apikeys',
    tags=['app_apikeys_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_apikeys_list(
    app_id: int = Path(..., alias='appId'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters6] = None,
    order: Optional[Order6] = None,
):
    """
    Get all api keys
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/apikeys',
    tags=['app_apikeys_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_apikeys_create(
    app_id: int = Path(..., alias='appId'),
    name: str = ...,
    api_partner_id: Optional[int] = None,
):
    """
    Create new API key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/apikeys/{id}',
    tags=['app_apikeys_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_apikeys_delete(app_id: int = Path(..., alias='appId'), id: str = ...):
    """
    Remove an api key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/apipartners', tags=['app_apipartners_management'], security=[])
def app_apipartners_list(
    app_id: int = Path(..., alias='appId'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters7] = None,
    order: Optional[Order7] = None,
):
    """
    Get all api parners
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/attachments',
    description=""" Get list of attachments """,
    tags=['app_attachment_management'],
    security=[],
)
def app_attachments_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters8] = None,
    order: Optional[Order8] = None,
):
    """
    List attachments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/attachments',
    tags=['app_attachment_management', 'app_file_attachment'],
    security=[],
)
def app_attachments_create(
    app_id: int = Path(..., alias='appId'),
    type: Type6 = ...,
    attachable_id: Optional[int] = None,
    file: Optional[bytes] = None,
):
    """
    Attach a file on an object
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/apps/{appId}/attachments',
    tags=['app_management', 'app_policies_management'],
    security=[],
)
def app_sap_attestations_generate_sap_attestations(
    app_id: int = Path(..., alias='appId')
):
    """
    Recreate S.A.P attestations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/attachments/download',
    tags=['app_attachment_management'],
    security=[],
)
def app_attachments_download(
    app_id: int = Path(..., alias='appId'), ids: Ids = ..., type: Type8 = ...
):
    """
    Download a list of attachments in pdf into a .zip file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/attachments/sap-download',
    tags=['app_attachment_management', 'accounting_export_management'],
    security=[],
)
def app_sap_attestations_download(
    app_id: int = Path(..., alias='appId'), ids: Ids = ..., type: Type8 = ...
):
    """
    Download a list of SAP attestations in pdf into a .zip file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/attachments/{id}', tags=['app_attachment_management'], security=[]
)
def app_attachments_delete(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Detach a file from id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/attachments/{id}', tags=['app_attachment_management'], security=[]
)
def app_attachments_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get attachment by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/attachments/{id}/pdf',
    tags=['app_attachment_management'],
    security=[],
)
def app_attachments__redirect_to_public_url(
    app_id: int = Path(..., alias='appId'), id: int = ..., random: int = ...
):
    """
    Download the attachment as pdf
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/bankdetails', tags=['app_bank_details_management'], security=[])
def app_documents_sales_bankdetails_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters9] = None,
    order: Optional[Order9] = None,
):
    """
    List BankDetails
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/bankdetails', tags=['app_bank_details_management'], security=[]
)
def app_documents_sales_bankdetails_create(
    app_id: int = Path(..., alias='appId'),
    name: Optional[str] = None,
    iban: Optional[str] = None,
    bic: Optional[str] = None,
):
    """
    Create a BankDetails
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/bankdetails/{id}', tags=['app_bank_details_management'], security=[]
)
def app_documents_sales_bankdetails_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a BankDetails
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/bankdetails/{id}', tags=['app_bank_details_management'], security=[]
)
def app_documents_sales_bankdetails_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a BankDetails
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/bankdetails/{id}', tags=['app_bank_details_management'], security=[]
)
def app_documents_sales_bankdetails_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: Optional[str] = None,
    iban: Optional[str] = None,
    bic: Optional[str] = None,
):
    """
    Update a BankDetails
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/banks/',
    description=""" The deletion of the account is irreversible, it will not be possible to resume synchronization as it is afterwards. - If transactions have been exported to accounting or used as payment, the CashflowSource will be left as it is. Resuming synchronization will remain impossible. If you re-import the account, a new CashflowSource will be created and transactions will therefore be duplicated. - Otherwise, if the CashflowSource was not used, it as well as its transactions will be deleted """,
    tags=['app_cashflow_management', 'app_bank_details_management'],
    security=[],
)
def app_cashflow_banks_delete(
    app_id: int = Path(..., alias='appId'), item_id: int = ...
):
    """
    Remove a Bankin synchronization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/banks/',
    tags=['app_bank_details_management', 'app_cashflow_management'],
    security=[],
)
def app_cashflow_banks_list(app_id: int = Path(..., alias='appId')):
    """
    List banks connected to bankin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/banks/connect',
    tags=['app_bank_details_management', 'app_cashflow_management'],
    security=[],
)
def app_cashflow_banks_connect(app_id: int = Path(..., alias='appId')):
    """
    Get the link to the funnel to connect a bank with Sinao
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/banks/synchronize',
    tags=['app_cashflow_management', 'app_cashflow_transactions'],
    security=[],
)
def app_cashflow_banks_synchronize(
    app_id: int = Path(..., alias='appId'),
    id: Optional[int] = None,
    is_incremential: Optional[bool] = None,
):
    """
    Triggers synchronization at Bankin then synchronizes transactions with Sinao
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/banks/{id}/funnel/edit',
    tags=['user_account_management', 'user_authentication'],
    security=[],
)
def app_cashflow_banks_url_edit(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get the link to the funnel to edit password
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/banks/{id}/funnel/sync',
    tags=['app_cashflow_management'],
    security=[],
)
def app_cashflow_banks_url_sync(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get the link to the funnel to start manually a synchronization (SCA)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/banks/{id}/funnel/validate',
    tags=['app_management', 'app_statistics_and_templates'],
    security=[],
)
def app_cashflow_banks_url_validate(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get the link to the funnel to validate a pro item (SCA)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/banks/{id}/select_accounts',
    tags=['app_cashflow_management', 'app_bank_details_management'],
    security=[],
)
def app_cashflow_banks_select_accounts(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    bank_account_ids: Optional[BankAccountIds] = None,
):
    """
    Select accounts to synchronize
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/cashflowsources/',
    tags=['app_cashflow_source_management', 'app_cashflow_management'],
    security=[],
)
def app_cashflow_cashflowsources_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters10] = None,
    order: Optional[Order10] = None,
):
    """
    List CashflowSource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/cashflowsources/',
    tags=['app_cashflow_source_management'],
    security=[],
)
def app_cashflow_cashflowsources_create(
    app_id: int = Path(..., alias='appId'),
    name: Optional[str] = None,
    identifiant: Optional[str] = None,
    type: Optional[Type12] = None,
    balance_amount: Optional[int] = None,
    account_type: Optional[AccountType] = None,
    parent_cashflow_source_id: Optional[int] = None,
):
    """
    Create a CashflowSource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/cashflowsources/{id}',
    tags=['app_cashflow_source_management'],
    security=[],
)
def app_cashflow_cashflowsources_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a CashflowSource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/cashflowsources/{id}',
    tags=['app_cashflow_source_management'],
    security=[],
)
def app_cashflow_cashflowsources_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a CashflowSource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/cashflowsources/{id}',
    tags=['app_cashflow_source_management', 'app_cashflow_management'],
    security=[],
)
def app_cashflow_cashflowsources_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: Optional[str] = None,
    identifiant: Optional[str] = None,
    type: Optional[Type12] = None,
    balance_amount: Optional[int] = None,
    account_type: Optional[AccountType] = None,
    parent_cashflow_source_id: Optional[int] = None,
):
    """
    Update a CashflowSource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/contacts/merge', tags=['app_contact_management'], security=[])
def app_contacts_transform_merge(
    app_id: int = Path(..., alias='appId'), contacts: Contacts = ...
):
    """
    Merge many contacts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/email/batch', tags=['app_contact_management'], security=[])
def app_contacts_email_batch(
    app_id: int = Path(..., alias='appId'),
    from_: Optional[EmailStr] = Query(None, alias='from'),
    messages: Optional[Messages] = None,
    need_copy_bcc: Optional[bool] = False,
):
    """
    Send emails
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/email/document', tags=['app_contact_management'], security=[])
def app_contacts_email_send(
    app_id: int = Path(..., alias='appId'),
    from_: Optional[EmailStr] = Query(None, alias='from'),
    recipients: Recipients = ...,
    recipients_cc: Optional[RecipientsCc] = None,
    recipients_bcc: Optional[RecipientsBcc] = None,
    title: Optional[str] = None,
    body: Optional[str] = None,
    documents: Documents = ...,
    need_copy_bcc: Optional[bool] = False,
):
    """
    Send an email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/establishments/{id}',
    description=""" Remove an establishment """,
    tags=['establishment_management'],
    security=[],
)
def app_contacts_establishments_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove an establishment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/establishments/{id}',
    description=""" Get an establishment by id """,
    tags=['establishment_management'],
    security=[],
)
def app_contacts_establishments_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get an establishment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/establishments/{id}',
    description=""" Update an establishment by id """,
    tags=['establishment_management'],
    security=[],
)
def app_contacts_establishments_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: Optional[str] = None,
    phones: Optional[Phones] = None,
    emails: Optional[Emails] = None,
    nic: Optional[constr(pattern=r'/^[0-9]{5}$/i')] = None,
    place: Optional[Place1] = None,
):
    """
    Update an establishment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/exports', tags=['accounting_export_management'], security=[])
def app_accounting_export_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters11] = None,
    order: Optional[Order11] = None,
):
    """
    List ExportEntity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/exports', tags=['accounting_export_management'], security=[])
def app_accounting_export_create(
    app_id: int = Path(..., alias='appId'), until: datetime = ...
):
    """
    Create a ExportEntity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/exports/acd_compta',
    description=""" If response UUID is empty, you must register your identifiants. """,
    tags=['user_authentication', 'app_management'],
    security=[],
)
def app_accounting_export__acd_compta_get_uuid(app_id: int = Path(..., alias='appId')):
    """
    Get the ACD UUID for authentification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/exports/acd_compta',
    description=""" Sinao will try to connect ACD authentification with your ids. If succed, Sinao will store your ids. """,
    tags=['user_account_management', 'user_authentication'],
    security=[],
)
def app_accounting_export__acd_compta_set_uuid(
    app_id: int = Path(..., alias='appId'),
    login: str = ...,
    password: str = ...,
    base: constr(pattern=r'/^3[A-Z]{3,}$/i') = ...,
    cnx: str = ...,
):
    """
    Register ACD identifiants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/exports/download', tags=['accounting_export_management'], security=[]
)
def app_accounting_export_download(
    app_id: int = Path(..., alias='appId'),
    format: Optional[Format] = None,
    export_entities_ids: Optional[ExportEntitiesIds] = None,
    start_at: Optional[datetime] = None,
    end_at: Optional[datetime] = None,
    since: Optional[datetime] = None,
    since_last: Optional[bool] = None,
):
    """
    Download the export entity as zip
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/exports/months', tags=['accounting_export_management'], security=[]
)
def app_accounting_export_list_by_months(app_id: int = Path(..., alias='appId')):
    """
    List ExportEntity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/exports/{id}', tags=['accounting_export_management'], security=[]
)
def app_accounting_export_delete(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Remove a ExportEntity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/exports/{id}', tags=['accounting_export_management'], security=[]
)
def app_accounting_export_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a ExportEntity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/invoices',
    description=""" Get list of invoices """,
    tags=['invoice_management'],
    security=[],
)
def app_documents_sales_invoices_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters12] = None,
    order: Optional[Order12] = None,
):
    """
    List invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices',
    description=""" Create a new invoice with an Organization or a Person. Relationship store notes, metadata and accounting settings parameters """,
    tags=[
        'invoice_management',
        'payments_management',
        'quote_management',
        'recurring_invoice_management',
    ],
    security=[],
)
def app_documents_sales_invoices_create(
    app_id: int = Path(..., alias='appId'),
    contact_infos: Optional[ContactInfos2] = None,
    third_account: Optional[ThirdAccount2] = None,
    title: Optional[str] = None,
    content: Optional[Content] = None,
    columns: Optional[Columns] = None,
    reference: Optional[str] = None,
    discount: Optional[Discount2] = None,
    currency: Optional[str] = None,
    legal_notice: Optional[str] = None,
    bank_details_id: Optional[int] = None,
    vat_exemption: Optional[VatExemption1] = None,
    tags: Optional[Tags] = None,
    metadata: Optional[Metadata] = None,
    downpayments: Optional[Downpayments] = None,
    downpayment_cash: Optional[int] = None,
    avoid_of: Optional[int] = None,
    delivered_at: Optional[datetime] = None,
    payment_period: Optional[int] = 30,
    payment_methods: Optional[str] = 'virement bancaire, chèque',
    number_from_other_software: Optional[str] = None,
):
    """
    Create an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/invoices/batch',
    description=""" Delete many invoices """,
    tags=['invoice_management'],
    security=[],
)
def app_documents_sales_invoices_batch_delete(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Delete many invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/batch',
    description=""" Create or update many invoices """,
    tags=['invoice_management', 'recurring_invoice_management'],
    security=[],
)
def app_documents_sales_invoices_batch(
    app_id: int = Path(..., alias='appId'), data: Data1 = ...
):
    """
    Create or update many invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/invoices/download',
    tags=[
        'invoice_management',
        'accounting_export_management',
        'app_attachment_management',
    ],
    security=[],
)
def app_documents_sales_invoices_download(
    app_id: int = Path(..., alias='appId'),
    ids: Ids = ...,
    template: Optional[Template] = None,
):
    """
    Download a list of invoices in pdf into a .zip file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/fresh',
    tags=['invoice_management', 'app_accounting_entries_management'],
    security=[],
)
def app_documents_sales_invoices_fresh(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Regenerate pdf and recalcul amounts of invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/invoices/nextnumber',
    tags=['invoice_management', 'recurring_invoice_management'],
    security=[],
)
def app_documents_sales_invoices_nextnumber(
    app_id: int = Path(..., alias='appId'), written_at: Optional[datetime] = None
):
    """
    Get the next invoice number for preview
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/invoices/statistics',
    tags=['invoice_management', 'sales_statistics'],
    security=[],
)
def app_documents_sales_invoices_statistics(
    app_id: int = Path(..., alias='appId'),
    search: Optional[str] = None,
    filters: Optional[Filters13] = None,
):
    """
    Obtain statistics about invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/invoices/{id}',
    description=""" Remove an invoice by id : only for draft """,
    tags=['invoice_management'],
    security=[],
)
def app_documents_sales_invoices_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/invoices/{id}',
    description=""" Get an Sales/Invoice object by Id """,
    tags=['invoice_management'],
    security=[],
)
def app_documents_sales_invoices_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/{id}',
    description=""" Update an invoice by id """,
    tags=['invoice_management', 'payments_management'],
    security=[],
)
def app_documents_sales_invoices_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    contact_infos: Optional[ContactInfos4] = None,
    third_account: Optional[ThirdAccount4] = None,
    title: Optional[str] = None,
    content: Optional[Content] = None,
    columns: Optional[Columns] = None,
    reference: Optional[str] = None,
    discount: Optional[Discount2] = None,
    currency: Optional[str] = None,
    legal_notice: Optional[str] = None,
    bank_details_id: Optional[int] = None,
    vat_exemption: Optional[VatExemption1] = None,
    tags: Optional[Tags] = None,
    metadata: Optional[Metadata] = None,
    downpayments: Optional[Downpayments] = None,
    downpayment_cash: Optional[int] = None,
    avoid_of: Optional[int] = None,
    delivered_at: Optional[datetime] = None,
    payment_period: Optional[int] = 30,
    payment_methods: Optional[str] = 'virement bancaire, chèque',
):
    """
    Update an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/invoices/{id}/attach',
    tags=['invoice_attachment_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_invoices_detach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file_id: Optional[int] = None
):
    """
    Detach a file at an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/{id}/attach',
    tags=['invoice_attachment_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_invoices_attach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file: Optional[bytes] = None
):
    """
    Attach a file at an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/{id}/avoid',
    tags=['invoice_management', 'app_accounting_entries_management'],
    security=[],
)
def app_documents_sales_invoices_avoid(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Create a creditnote on an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/{id}/duplicate', tags=['invoice_management'], security=[]
)
def app_documents_sales_invoices_duplicate(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Duplicate an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/{id}/finalize', tags=['invoice_management'], security=[]
)
def app_documents_sales_invoices_finalize(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    force_date: Optional[bool] = None,
):
    """
    Finalize an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/invoices/{id}/pdf',
    tags=[
        'invoice_management',
        'accounting_export_management',
        'app_attachment_management',
    ],
    security=[],
)
def app_documents_sales_invoices_pdf(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    template: Optional[Template] = None,
):
    """
    Download the invoice as pdf
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/invoices/{id}/preview.jpg',
    tags=[
        'app_attachment_management',
        'invoice_management',
        'invoice_attachment_management',
    ],
    security=[],
)
def app_documents_sales_invoices_preview(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    template: Optional[str] = None,
    disable_cache: Optional[bool] = None,
    base64: Optional[bool] = None,
):
    """
    Download invoice as jpeg
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/invoices/{id}/tag',
    tags=['invoice_management', 'invoice_attachment_management'],
    security=[],
)
def app_documents_sales_invoices_untag(
    app_id: int = Path(..., alias='appId'), id: int = ..., tag: Optional[str] = None
):
    """
    Delete a tag on an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/{id}/tag',
    tags=['invoice_management', 'invoice_attachment_management'],
    security=[],
)
def app_documents_sales_invoices_tag(
    app_id: int = Path(..., alias='appId'), id: int = ..., tag: Optional[str] = None
):
    """
    Add a tag on an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/invoices/{id}/updatestatus', tags=['invoice_management'], security=[]
)
def app_documents_sales_invoices_updatestatus(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    status: Optional[Status3] = None,
):
    """
    Update the status of an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/logs/autoreconcile/',
    tags=['cashflow_autoreconciliation'],
    security=[],
)
def app_cashflow_logsautoreconciliations_clear(app_id: int = Path(..., alias='appId')):
    """
    Clear autoreconciliation logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/logs/autoreconcile/',
    tags=['cashflow_autoreconciliation'],
    security=[],
)
def app_cashflow_logsautoreconciliations_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters14] = None,
    order: Optional[Order13] = None,
):
    """
    List autoreconciliation logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/logs/autoreconcile/',
    tags=['cashflow_autoreconciliation'],
    security=[],
)
def app_cashflow_logsautoreconciliations_start(app_id: int = Path(..., alias='appId')):
    """
    Start force autoreconciliation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/organization',
    tags=['organization_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_organization_get(app_id: int = Path(..., alias='appId')):
    """
    Get organization profile for current app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/organization',
    tags=['organization_profile_management', 'establishment_management'],
    security=[],
)
def app_organization_update(
    app_id: int = Path(..., alias='appId'),
    name: Optional[constr(pattern=r'/^.*[a-z]+.*$/i')] = None,
    billing_name: Optional[str] = None,
    logo: Optional[Logo] = None,
    legal_form: Optional[str] = None,
    country_iso2: Optional[str] = None,
    founding_date: Optional[date_aliased] = None,
    founding_location: Optional[str] = None,
    dissolution_date: Optional[date_aliased] = None,
    closeaccounting_period: Optional[str] = None,
    national_id: Optional[str] = None,
    trade_directory_registration: Optional[str] = None,
    vat_id: Optional[str] = None,
    code_naf: Optional[constr(pattern=r'/^[0-9]+[a-z]$/i')] = None,
    number_of_employees: Optional[str] = None,
    industry: Optional[str] = None,
    slogan: Optional[str] = None,
    rcs: Optional[str] = None,
    greffe: Optional[str] = None,
    sap_number_registration: Optional[constr(pattern=r'/^SAP[0-9]{9}$/i')] = None,
    sap_activities: Optional[str] = None,
    sap_date_registration: Optional[
        constr(pattern=r'/^[0-9]{2}\/[0-9]{2}\/[0-9]{4}$/i')
    ] = None,
    capital: Optional[int] = None,
):
    """
    Update organization profile for current app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/organizations',
    description=""" List all organizations """,
    tags=['organization_profile_management', 'contacts_organizations_management'],
    security=[],
)
def app_contacts_organizations_list(
    app_id: int = Path(..., alias='appId'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters15] = None,
    order: Optional[Order14] = None,
):
    """
    List organizations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/organizations',
    description=""" Create a contact organization. This organization will be automatically completed and updated by public data. The public profile will be automatically find by NationalID """,
    tags=['organization_profile_management', 'establishment_management'],
    security=[],
)
def app_contacts_organizations_create(
    app_id: int = Path(..., alias='appId'),
    name: constr(pattern=r'/^.*[a-z0-9]+.*$/i') = ...,
    billing_name: Optional[str] = None,
    logo: Optional[Logo] = None,
    legal_form: Optional[str] = None,
    country_iso2: Optional[str] = None,
    founding_date: Optional[date_aliased] = None,
    founding_location: Optional[str] = None,
    dissolution_date: Optional[date_aliased] = None,
    vat_system: Optional[str] = None,
    closeaccounting_period: Optional[str] = None,
    national_id: Optional[str] = None,
    vat_id: Optional[str] = None,
    code_naf: Optional[constr(pattern=r'/^[0-9]{4}[a-z]$/i')] = None,
    number_of_employees: Optional[str] = None,
    slogan: Optional[str] = None,
    rcs: Optional[str] = None,
    greffe: Optional[str] = None,
    capital: Optional[int] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Create an organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/organizations/batch',
    description=""" Create a contact organization. This organization will be automatically completed and updated by public data. The public profile will be automatically find by NationalID """,
    tags=['organization_profile_management', 'contacts_organizations_management'],
    security=[],
)
def app_contacts_organizations_batch(
    app_id: int = Path(..., alias='appId'), data: Data2 = ...
):
    """
    Create multiple organizations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/organizations/{id}',
    description=""" Remove an organization """,
    tags=['organization_profile_management', 'contacts_organizations_management'],
    security=[],
)
def app_contacts_organizations_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove an organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/organizations/{id}',
    description=""" Get an organization by id """,
    tags=['organization_profile_management', 'contacts_organizations_management'],
    security=[],
)
def app_contacts_organizations_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get an organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/organizations/{id}',
    description=""" Update an organization by id """,
    tags=['organization_profile_management', 'contacts_organizations_management'],
    security=[],
)
def app_contacts_organizations_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: Optional[constr(pattern=r'/^.*[a-z]+.*$/i')] = None,
    billing_name: Optional[str] = None,
    logo: Optional[Logo] = None,
    legal_form: Optional[str] = None,
    country_iso2: Optional[str] = None,
    founding_date: Optional[date_aliased] = None,
    founding_location: Optional[str] = None,
    dissolution_date: Optional[date_aliased] = None,
    vat_system: Optional[str] = None,
    closeaccounting_period: Optional[str] = None,
    national_id: Optional[str] = None,
    vat_id: Optional[str] = None,
    code_naf: Optional[constr(pattern=r'/^[0-9]{4}[a-z]$/i')] = None,
    number_of_employees: Optional[str] = None,
    slogan: Optional[str] = None,
    rcs: Optional[str] = None,
    greffe: Optional[str] = None,
    capital: Optional[int] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Update an organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/organizations/{id}/restore',
    description=""" Restore an organization by id """,
    tags=['organization_profile_management'],
    security=[],
)
def app_contacts_organizations_restore(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Restore an organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/payments',
    description=""" Get list of payments """,
    tags=['payments_management'],
    security=[],
)
def app_payments_payments_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters16] = None,
    order: Optional[Order15] = None,
):
    """
    List payments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/payments/recipe_book',
    description=""" Get a Payment object by Id """,
    tags=['app_management'],
    security=[],
)
def app_payments_payments_recipe_book(app_id: int = Path(..., alias='appId')):
    """
    Get the recipe book
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/payments/{id}',
    description=""" Remove a payment by id """,
    tags=['payments_management'],
    security=[],
)
def app_payments_payments_delete(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Remove a payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/payments/{id}',
    description=""" Get a Payment object by Id """,
    tags=['payments_management'],
    security=[],
)
def app_payments_payments_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/persons',
    description=""" Get all persons """,
    tags=['user_account_management', 'contacts_persons_management'],
    security=[],
)
def app_contacts_persons_list(
    app_id: int = Path(..., alias='appId'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters17] = None,
    order: Optional[Order16] = None,
):
    """
    List persons
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/persons',
    description=""" Create a new person. Represent a private contact """,
    tags=['user_account_management', 'contacts_persons_management'],
    security=[],
)
def app_contacts_persons_create(
    app_id: int = Path(..., alias='appId'),
    civility: Optional[str] = None,
    lastname: str = ...,
    firstname: Optional[str] = None,
    picture: Optional[Picture] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Create a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/persons/batch',
    description=""" Create a new person. Represent a private contact """,
    tags=['contacts_persons_management', 'user_account_management'],
    security=[],
)
def app_contacts_persons_batch(
    app_id: int = Path(..., alias='appId'), data: Data3 = ...
):
    """
    Create multiple persons
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/persons/{id}',
    description=""" Remove an person """,
    tags=['user_account_management', 'app_management'],
    security=[],
)
def app_contacts_persons_delete(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Remove a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/persons/{id}',
    description=""" Get a person by id """,
    tags=['user_account_management'],
    security=[],
)
def app_contacts_persons_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/persons/{id}',
    description=""" Update a person by id """,
    tags=['user_account_management', 'contacts_persons_management'],
    security=[],
)
def app_contacts_persons_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    civility: Optional[str] = None,
    lastname: Optional[str] = None,
    firstname: Optional[str] = None,
    picture: Optional[Picture] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Update a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/persons/{id}/restore',
    description=""" Restore a person by id """,
    tags=['user_account_management'],
    security=[],
)
def app_contacts_persons_restore(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Restore a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/ping',
    description=""" Try if a specific app is online """,
    tags=['app_health_check'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_ping(app_id: int = Path(..., alias='appId')):
    """
    Ping app web hostname
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/productcategory',
    description=""" Get list of product categories """,
    tags=['catalog_categories_management'],
    security=[],
)
def app_catalog_categories_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters18] = None,
    order: Optional[Order17] = None,
):
    """
    List product categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/productcategory',
    description=""" Create a new product category """,
    tags=['catalog_categories_management', 'product_management'],
    security=[],
)
def app_catalog_categories_create(
    app_id: int = Path(..., alias='appId'),
    name: str = ...,
    image: Optional[Image] = None,
    parent_category_id: Optional[int] = None,
):
    """
    Create a product category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/productcategory/{id}',
    description=""" Remove a product category by id """,
    tags=['catalog_categories_management'],
    security=[],
)
def app_catalog_categories_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a product category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/productcategory/{id}',
    description=""" Get a Product category object by Id """,
    tags=['catalog_categories_management'],
    security=[],
)
def app_catalog_categories_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a product category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/productcategory/{id}',
    description=""" Update a product category by id """,
    tags=['catalog_categories_management', 'product_management'],
    security=[],
)
def app_catalog_categories_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: str = ...,
    image: Optional[Image] = None,
    parent_category_id: Optional[int] = None,
):
    """
    Update a product category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/products',
    description=""" Get list of products """,
    tags=['product_management', 'catalog_categories_management'],
    security=[],
)
def app_catalog_products_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters19] = None,
    order: Optional[Order18] = None,
):
    """
    List products
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/products',
    description=""" Create a new product """,
    tags=['product_management', 'catalog_categories_management', 'stock_management'],
    security=[],
)
def app_catalog_products_create(
    app_id: int = Path(..., alias='appId'),
    name: str = ...,
    amount: Optional[int] = None,
    amount_accurately: Optional[int] = None,
    vat_percent: Optional[conint(ge=0)] = None,
    image: Optional[Image] = None,
    lifetime: Optional[int] = None,
    description: Optional[str] = None,
    type: Optional[Type30] = None,
    quantity_name: Optional[str] = None,
    reference: Optional[str] = None,
    account_id: Optional[str] = None,
    tags: Optional[Tags2] = None,
    category_id: Optional[int] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Create a product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/products/batch',
    description=""" Create a new product """,
    tags=['product_management', 'catalog_categories_management'],
    security=[],
)
def app_catalog_products_batch(
    app_id: int = Path(..., alias='appId'), data: Data4 = ...
):
    """
    Create multiple products
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/products/{id}',
    description=""" Remove a product by id """,
    tags=['product_management', 'stock_management'],
    security=[],
)
def app_catalog_products_delete(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Remove a product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/products/{id}',
    description=""" Get a Product object by Id """,
    tags=['product_management'],
    security=[],
)
def app_catalog_products_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/products/{id}',
    description=""" Update a product by id """,
    tags=['product_management', 'catalog_categories_management'],
    security=[],
)
def app_catalog_products_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: Optional[str] = None,
    amount: Optional[int] = None,
    amount_accurately: Optional[int] = None,
    vat_percent: Optional[conint(ge=0)] = None,
    image: Optional[Image] = None,
    lifetime: Optional[int] = None,
    description: Optional[str] = None,
    type: Optional[Type30] = None,
    quantity_name: Optional[str] = None,
    reference: Optional[str] = None,
    account_id: Optional[str] = None,
    tags: Optional[Tags2] = None,
    category_id: Optional[int] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Update a product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/products/{id}/attach',
    tags=['app_attachment_management'],
    security=[],
)
def app_catalog_products_detach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file_id: Optional[int] = None
):
    """
    Detach a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/products/{id}/attach',
    tags=['app_attachment_management', 'app_file_attachment'],
    security=[],
)
def app_catalog_products_attach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file: Optional[bytes] = None
):
    """
    Attach a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/productstocks',
    description=""" Get list of stocks """,
    tags=['stock_management'],
    security=[],
)
def app_catalog_stocks_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters20] = None,
    order: Optional[Order19] = None,
):
    """
    List stocks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/productstocks',
    description=""" Create a new stocks """,
    tags=['stock_management', 'product_management', 'purchase_management'],
    security=[],
)
def app_catalog_stocks_create(
    app_id: int = Path(..., alias='appId'),
    product_id: int = ...,
    purchase_id: Optional[int] = None,
    quantity: Optional[int] = None,
    bar_code: Optional[str] = None,
    location: Optional[str] = None,
    entered_at: Optional[datetime] = None,
    expired_at: Optional[datetime] = None,
    cost_amount: Optional[int] = None,
    use_duration: Optional[int] = None,
):
    """
    Create a stocks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/productstocks/{id}',
    description=""" Remove a stocks by id """,
    tags=['stock_management'],
    security=[],
)
def app_catalog_stocks_delete(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Remove a stocks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/productstocks/{id}',
    description=""" Get a Product object by Id """,
    tags=['stock_management'],
    security=[],
)
def app_catalog_stocks_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a stocks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/productstocks/{id}',
    description=""" Update a stocks by id """,
    tags=['stock_management', 'purchase_management'],
    security=[],
)
def app_catalog_stocks_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    purchase_id: Optional[int] = None,
    bar_code: Optional[str] = None,
    location: Optional[str] = None,
    entered_at: Optional[datetime] = None,
    expired_at: Optional[datetime] = None,
    cost_amount: Optional[int] = None,
    use_duration: Optional[int] = None,
):
    """
    Update a stocks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/productstocks/{id}/destruct',
    description=""" Update a stocks by id to reduce quantity of stocks """,
    tags=['stock_management'],
    security=[],
)
def app_catalog_stocks_destruct(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    quantity: Optional[int] = None,
    comment: Optional[str] = None,
):
    """
    Destruct a quantity of stock (forgotten, destructed, expirated stock...)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/productstocks/{id}/rental/back',
    description=""" Update the amount of stocks available through the return of rented stocks """,
    tags=['stock_management'],
    security=[],
)
def app_catalog_stocks_rental_back(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    quantity: int = ...,
    current_return_date: Optional[datetime] = 'now',
    use_duration: Optional[int] = 0,
    comment: Optional[str] = None,
):
    """
    Consider part of the stock as back
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/productstocks/{id}/rental/exit',
    description=""" Updates the quantity of available stocks and provides for a stocks return date """,
    tags=['app_accounting_entries_management', 'stock_management'],
    security=[],
)
def app_catalog_stocks_rental_exit(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    quantity: Optional[int] = None,
    future_return_date: Optional[datetime] = None,
    comment: Optional[str] = None,
):
    """
    Consider part of the stock as rented
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/purchases',
    description=""" Get list of purchases """,
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters21] = None,
    order: Optional[Order20] = None,
    expand: Optional[Expand] = None,
):
    """
    List purchases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/purchases',
    description=""" Create a new purchase with an Organization. Relationship store notes, metadata and accounting settings parameters """,
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_create(
    app_id: int = Path(..., alias='appId'),
    invoice: Optional[bytes] = None,
    account_id: Optional[int] = None,
    supplier_organization_id: Optional[int] = None,
    title: Optional[str] = None,
    supplier_name: Optional[str] = None,
    amount: Optional[int] = None,
    amount_tax: Optional[int] = None,
    currency: Optional[str] = None,
    vat_detail: Optional[VatDetail] = None,
    billed_at: Optional[date_aliased] = None,
    comment: Optional[int] = None,
    tags: Optional[Tags2] = None,
    vat_repayment: Optional[VatRepayment] = None,
    payment_deadline_at: Optional[date_aliased] = None,
    payment_account_number: Optional[str] = None,
    payment_routing_number: Optional[str] = None,
    payment_swift: Optional[str] = None,
    payment_iban: Optional[str] = None,
):
    """
    Create a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/purchases/batch',
    description=""" Delete many purchases """,
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_batch_delete(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Delete many purchases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/purchases/batch',
    description=""" Create or update many purchases """,
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_batch(
    app_id: int = Path(..., alias='appId'), data: Data5 = ...
):
    """
    Create or update many purchases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/purchases/download',
    tags=['app_attachment_management', 'purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_download(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Download a list of purchases in pdf into a .zip file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/purchases/statistics',
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_statistics(
    app_id: int = Path(..., alias='appId'),
    search: Optional[str] = None,
    filters: Optional[Filters22] = None,
):
    """
    Obtain statistics about purchases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/purchases/{id}',
    description=""" Remove a purchase by id """,
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/purchases/{id}',
    description=""" Get an Purchase/Purchase object by Id """,
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/purchases/{id}',
    description=""" Update a purchase by id """,
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    account_id: Optional[int] = None,
    supplier_organization_id: Optional[int] = None,
    title: Optional[str] = None,
    supplier_name: Optional[str] = None,
    amount: Optional[int] = None,
    amount_tax: Optional[int] = None,
    currency: Optional[str] = None,
    vat_detail: Optional[VatDetail] = None,
    billed_at: Optional[date_aliased] = None,
    comment: Optional[int] = None,
    tags: Optional[Tags2] = None,
    vat_repayment: Optional[VatRepayment] = None,
    payment_deadline_at: Optional[date_aliased] = None,
    payment_account_number: Optional[str] = None,
    payment_routing_number: Optional[str] = None,
    payment_swift: Optional[str] = None,
    payment_iban: Optional[str] = None,
    purchase_lines: Optional[PurchaseLines] = None,
):
    """
    Update a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/purchases/{id}/attach',
    tags=['app_attachment_management', 'purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_detach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file_id: Optional[int] = None
):
    """
    Detach a file at a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/purchases/{id}/attach',
    tags=['app_attachment_management', 'purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_attach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file: Optional[bytes] = None
):
    """
    Attach a file at a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/purchases/{id}/original',
    tags=['app_attachment_management', 'purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_original(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Download the purchase as pdf
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/purchases/{id}/preview.jpg',
    tags=['app_attachment_management', 'purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_preview(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Download purchase as jpeg
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/purchases/{id}/tag',
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_untag(
    app_id: int = Path(..., alias='appId'), id: int = ..., tag: Optional[str] = None
):
    """
    Delete a tag on a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/purchases/{id}/tag',
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_tag(
    app_id: int = Path(..., alias='appId'), id: int = ..., tag: Optional[str] = None
):
    """
    Add a tag on a purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/purchases/{id}/thumbnail.jpg',
    tags=['purchase_management', 'purchase_operations'],
    security=[],
)
def app_documents_purchases_purchases_thumbnail(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Show purchase thumbnail as jpeg
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/purchases/{id}/updatestatus',
    tags=['invoice_management'],
    security=[],
)
def app_documents_purchases_purchases_updatestatus(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    status: Optional[Status5] = None,
):
    """
    Update the status of an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes',
    description=""" Get list of quotes """,
    tags=['quote_management', 'quote_statistics_and_preview'],
    security=[],
)
def app_documents_sales_quotes_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters23] = None,
    order: Optional[Order21] = None,
):
    """
    List quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes',
    description=""" Create a new quote with an Organization or a Person. Relationship store notes, metadata and accounting settings parameters """,
    tags=['quote_management'],
    security=[],
)
def app_documents_sales_quotes_create(
    app_id: int = Path(..., alias='appId'),
    contact_infos: Optional[ContactInfos6] = None,
    third_account: Optional[ThirdAccount6] = None,
    title: Optional[str] = None,
    content: Optional[Content] = None,
    columns: Optional[Columns] = None,
    reference: Optional[str] = None,
    discount: Optional[Discount2] = None,
    currency: Optional[str] = None,
    legal_notice: Optional[str] = None,
    bank_details_id: Optional[int] = None,
    vat_exemption: Optional[VatExemption5] = None,
    tags: Optional[Tags2] = None,
    metadata: Optional[Metadata] = None,
    downpayment_request: Optional[DownpaymentRequest1] = None,
    commercialvalidity_deadline: Optional[datetime] = None,
    number_from_other_software: Optional[str] = None,
):
    """
    Create a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/quotes/batch',
    description=""" Delete many quotes """,
    tags=['quote_management'],
    security=[],
)
def app_documents_sales_quotes_batch_delete(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Delete many quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/batch',
    description=""" Create or update many quotes """,
    tags=['quote_management'],
    security=[],
)
def app_documents_sales_quotes_batch(
    app_id: int = Path(..., alias='appId'), data: Data6 = ...
):
    """
    Create or update many quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes/download',
    tags=['quote_management', 'quote_file_operations'],
    security=[],
)
def app_documents_sales_quotes_download(
    app_id: int = Path(..., alias='appId'),
    ids: Ids = ...,
    template: Optional[Template] = None,
):
    """
    Download a list of quotes in pdf into a .zip file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/quotes/fresh', tags=['quote_management'], security=[])
def app_documents_sales_quotes_fresh(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Regenerate pdf and recalcul amounts of quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/invoice',
    description=""" Create or update many quotes """,
    tags=['quote_management'],
    security=[],
)
def app_documents_sales_quotes_invoices(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Create or update many quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes/nextnumber',
    tags=['quote_management', 'quote_statistics_and_preview'],
    security=[],
)
def app_documents_sales_quotes_nextnumber(
    app_id: int = Path(..., alias='appId'), written_at: Optional[datetime] = None
):
    """
    Get the next quote number for preview
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes/statistics',
    tags=['quote_statistics_and_preview'],
    security=[],
)
def app_documents_sales_quotes_statistics(
    app_id: int = Path(..., alias='appId'),
    search: Optional[str] = None,
    filters: Optional[Filters24] = None,
):
    """
    Obtain statistics about quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/quotes/{id}',
    description=""" Remove a quote by id : only for draft """,
    tags=['quote_management'],
    security=[],
)
def app_documents_sales_quotes_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes/{id}',
    description=""" Get a Sales/Quote object by Id """,
    tags=['quote_management', 'quote_statistics_and_preview'],
    security=[],
)
def app_documents_sales_quotes_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/{id}',
    description=""" Update a quote by id """,
    tags=['quote_management'],
    security=[],
)
def app_documents_sales_quotes_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    contact_infos: Optional[ContactInfos8] = None,
    third_account: Optional[ThirdAccount8] = None,
    title: Optional[str] = None,
    content: Optional[Content] = None,
    columns: Optional[Columns] = None,
    reference: Optional[str] = None,
    discount: Optional[Discount2] = None,
    currency: Optional[str] = None,
    legal_notice: Optional[str] = None,
    bank_details_id: Optional[int] = None,
    vat_exemption: Optional[VatExemption5] = None,
    tags: Optional[Tags2] = None,
    metadata: Optional[Metadata] = None,
    downpayment_request: Optional[DownpaymentRequest1] = None,
    commercialvalidity_deadline: Optional[datetime] = None,
):
    """
    Update a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/quotes/{id}/attach',
    tags=['app_attachment_management', 'quote_file_operations'],
    security=[],
)
def app_documents_sales_quotes_detach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file_id: Optional[int] = None
):
    """
    Detach a file at a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/{id}/attach',
    tags=['app_attachment_management', 'quote_file_operations'],
    security=[],
)
def app_documents_sales_quotes_attach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file: Optional[bytes] = None
):
    """
    Attach a file at a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/{id}/downpayment',
    tags=['quote_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_quotes_downpayment(
    app_id: int = Path(..., alias='appId'), id: int = ..., percent: int = ...
):
    """
    Transform the quote in a downpayment invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/quotes/{id}/duplicate', tags=['quote_management'], security=[])
def app_documents_sales_quotes_duplicate(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Duplicate a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/quotes/{id}/finalize', tags=['quote_management'], security=[])
def app_documents_sales_quotes_finalize(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Finalize a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/{id}/invoice',
    tags=['invoice_management', 'quote_management'],
    security=[],
)
def app_documents_sales_quotes_invoice(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Transform the quote in invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes/{id}/pdf',
    tags=['quote_management', 'quote_file_operations'],
    security=[],
)
def app_documents_sales_quotes_pdf(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    template: Optional[Template] = None,
):
    """
    Download the quote as pdf
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes/{id}/preview.jpg',
    tags=['quote_management', 'quote_file_operations'],
    security=[],
)
def app_documents_sales_quotes_preview(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    template: Optional[Template] = None,
):
    """
    Download quote as jpeg
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/{id}/situation_invoice',
    tags=['quote_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_quotes_situation_invoice(
    app_id: int = Path(..., alias='appId'), id: int = ..., progress: int = ...
):
    """
    Transform the quote into a situation invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/quotes/{id}/tag',
    tags=['quote_management', 'quote_file_operations'],
    security=[],
)
def app_documents_sales_quotes_untag(
    app_id: int = Path(..., alias='appId'), id: int = ..., tag: Optional[str] = None
):
    """
    Delete a tag on a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/{id}/tag',
    tags=['quote_management', 'quote_file_operations'],
    security=[],
)
def app_documents_sales_quotes_tag(
    app_id: int = Path(..., alias='appId'), id: int = ..., tag: Optional[str] = None
):
    """
    Add a tag on an quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/quotes/{id}/updatestatus',
    tags=['quote_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_quotes_updatestatus(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    status: Optional[Status7] = None,
):
    """
    Update the status of a quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/quotes/{id}/yousign/preview.jpg',
    tags=['quote_management', 'quote_file_operations'],
)
def app_documents_sales_quotes_yousign_preview(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    template: Optional[Template] = None,
):
    """
    Download quote as jpeg
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/reconcile',
    description=""" Remove all payments of a parent object """,
    tags=['payments_management'],
    security=[],
)
def app_payments_reconciliation_unreconcile(
    app_id: int = Path(..., alias='appId'), type: Type42 = ..., id: int = ...
):
    """
    Remove payments by an object
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/reconcile',
    description=""" Create a new payments and categorizations by one-to-many """,
    tags=[
        'payment_reconciliation',
        'payment_reconciliation_operations',
        'app_cashflow_management',
    ],
    security=[],
)
def app_payments_reconciliation_reconcile(
    app_id: int = Path(..., alias='appId'),
    replace_all: Optional[bool] = False,
    type: Type46 = ...,
    id: int = ...,
    movements: Movements1 = ...,
    paid_at: Optional[datetime] = None,
    rule: Optional[Rule1] = None,
):
    """
    Reconcile a transaction or a document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/reconcile/batch',
    description=""" Create new payments and categorizations by one-to-many """,
    tags=[
        'app_cashflow_management',
        'payment_reconciliation',
        'payment_reconciliation_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_payments_reconciliation_batch(
    app_id: int = Path(..., alias='appId'), data: Data7 = ...
):
    """
    Reconcile several transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/recurringinvoices',
    tags=['recurring_invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters25] = None,
    order: Optional[Order22] = None,
):
    """
    List RecurringInvoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/recurringinvoices',
    tags=['recurring_invoice_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_create(
    app_id: int = Path(..., alias='appId'),
    contact_infos: Optional[ContactInfos10] = None,
    title: Optional[str] = None,
    content: Optional[Content4] = None,
    columns: Optional[Columns] = None,
    currency: Optional[str] = None,
    legal_notice: Optional[str] = None,
    bank_details_id: Optional[int] = None,
    vat_exemption: Optional[VatExemption5] = None,
    tags: Optional[Tags8] = None,
    metadata: Optional[Metadata] = None,
    payment_period: Optional[int] = 30,
    next_invoice_at: Optional[datetime] = None,
    end_at: Optional[datetime] = None,
    frequency_count: int = ...,
    frequency_duration: FrequencyDuration = ...,
    discount: Optional[int] = None,
    discount_mode: Optional[DiscountMode] = None,
    discount_start_at: Optional[datetime] = None,
    discount_end_at: Optional[datetime] = None,
    details: Optional[str] = None,
    orders_plan: Optional[OrdersPlan] = None,
):
    """
    Create a RecurringInvoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/recurringinvoices/batch',
    description=""" Delete many RecurringInvoice """,
    tags=['recurring_invoice_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_batch_delete(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Delete many RecurringInvoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/recurringinvoices/batch',
    description=""" Create or update many RecurringInvoice """,
    tags=['recurring_invoice_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_batch(
    app_id: int = Path(..., alias='appId'), data: Data8 = ...
):
    """
    Create or update many RecurringInvoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/recurringinvoices/periods',
    description=""" Get json of periods_formats for a date. If request parameter date is null, returns periods_formats for today. """,
    tags=['app_statistics_and_templates', 'app_configuration_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_get_periods(
    app_id: int = Path(..., alias='appId'), date: Optional[datetime] = None
):
    """
    Get json of periods_formats for a date.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/recurringinvoices/{id}',
    tags=['recurring_invoice_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a RecurringInvoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/recurringinvoices/{id}',
    tags=['recurring_invoice_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a RecurringInvoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/recurringinvoices/{id}',
    tags=['recurring_invoice_management', 'invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    contact_infos: Optional[ContactInfos12] = None,
    title: Optional[str] = None,
    content: Optional[Content4] = None,
    columns: Optional[Columns] = None,
    currency: Optional[str] = None,
    legal_notice: Optional[str] = None,
    bank_details_id: Optional[int] = None,
    vat_exemption: Optional[VatExemption5] = None,
    tags: Optional[Tags8] = None,
    metadata: Optional[Metadata] = None,
    payment_period: Optional[int] = 30,
    next_invoice_at: Optional[datetime] = None,
    end_at: Optional[datetime] = None,
    frequency_count: Optional[int] = None,
    frequency_duration: Optional[FrequencyDuration] = None,
    discount: Optional[int] = None,
    discount_mode: Optional[DiscountMode] = None,
    discount_start_at: Optional[datetime] = None,
    discount_end_at: Optional[datetime] = None,
    details: Optional[str] = None,
    orders_plan: Optional[OrdersPlan1] = None,
):
    """
    Update a RecurringInvoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/recurringinvoices/{id}/plan',
    tags=['invoice_management', 'recurring_invoice_management'],
    security=[],
)
def app_documents_sales_recurringinvoices_plan(
    app_id: int = Path(..., alias='appId'), id: int = ..., until: datetime = ...
):
    """
    Preview next invoices generations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/relationships',
    description=""" List all relationships """,
    tags=['relationship_management'],
    security=[],
)
def app_contacts_relationships_list(
    app_id: int = Path(..., alias='appId'),
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters26] = None,
    order: Optional[Order23] = None,
):
    """
    List relationships
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/relationships/{id}',
    description=""" Get a relationship by id """,
    tags=['relationship_management'],
    security=[],
)
def app_contacts_relationships_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a relationship
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/relationships/{id}',
    description=""" Update a relationship by id """,
    tags=['relationship_management'],
    security=[],
)
def app_contacts_relationships_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    is_customer: Optional[bool] = None,
    is_supplier: Optional[bool] = None,
    is_prospect: Optional[bool] = None,
    importance_level: Optional[int] = None,
    rating: Optional[int] = None,
    balance_initial_amount: Optional[int] = None,
    is_notifying: Optional[bool] = None,
    note: Optional[str] = None,
    reference: Optional[str] = None,
    tags: Optional[str] = None,
    discount: Optional[str] = None,
    details: Optional[str] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Update a relationship
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/relationships/{id}/attach',
    tags=['app_attachment_management'],
    security=[],
)
def app_contacts_relationships_detach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file_id: Optional[int] = None
):
    """
    Detach a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/relationships/{id}/attach',
    tags=['app_attachment_management', 'app_file_attachment'],
    security=[],
)
def app_contacts_relationships_attach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file: Optional[bytes] = None
):
    """
    Attach a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/reset',
    description=""" Reset everything """,
    tags=['app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_reset(app_id: int = Path(..., alias='appId')):
    """
    Reset all data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/rules/', tags=['rules_management'], security=[])
def app_rules_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters27] = None,
    order: Optional[Order24] = None,
):
    """
    List rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/rules/', tags=['rules_management'], security=[])
def app_rules_create(
    app_id: int = Path(..., alias='appId'),
    conditions: Optional[Conditions] = None,
    on_event: Optional[str] = None,
    parameter: Optional[str] = None,
    value: Optional[str] = None,
    priority: Optional[int] = None,
):
    """
    Create a rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/rules/execute_on', tags=['rules_management'], security=[])
def app_rules_execute_on(
    app_id: int = Path(..., alias='appId'), model: Optional[str] = None
):
    """
    Execute all rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/apps/{appId}/rules/{id}', tags=['rules_management'], security=[])
def app_rules_delete(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Remove a rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/rules/{id}', tags=['rules_management'], security=[])
def app_rules_get(app_id: int = Path(..., alias='appId'), id: int = ...):
    """
    Get a rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/rules/{id}', tags=['rules_management'], security=[])
def app_rules_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    conditions: Optional[Conditions] = None,
    on_event: Optional[str] = None,
    parameter: Optional[str] = None,
    value: Optional[str] = None,
    priority: Optional[int] = None,
):
    """
    Update a rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/salesdocumentmodels',
    tags=['sales_document_model_management'],
    security=[],
)
def app_documents_sales_models_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters28] = None,
    order: Optional[Order25] = None,
):
    """
    List sales documents models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/salesdocumentmodels',
    tags=['sales_document_model_management'],
    security=[],
)
def app_documents_sales_models_create(
    app_id: int = Path(..., alias='appId'),
    name: Optional[str] = None,
    title: Optional[str] = None,
    content: Optional[Content6] = None,
    columns: Optional[Columns] = None,
):
    """
    Create a sales document model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/salesdocumentmodels/{id}',
    tags=['sales_document_model_management'],
    security=[],
)
def app_documents_sales_models_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a sales document model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/salesdocumentmodels/{id}',
    tags=['sales_document_model_management'],
    security=[],
)
def app_documents_sales_models_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a sales document model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/salesdocumentmodels/{id}',
    tags=['sales_document_model_management'],
    security=[],
)
def app_documents_sales_models_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    name: Optional[str] = None,
    title: Optional[str] = None,
    content: Optional[Content6] = None,
    columns: Optional[Columns] = None,
):
    """
    Update a sales document model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/sepamandates/', tags=['sepa_mandate_operations'], security=[])
def app_payments_sepamandates_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters29] = None,
    order: Optional[Order26] = None,
):
    """
    List SEPAMandate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/sepamandates/', tags=['sepa_mandate_operations'], security=[])
def app_payments_sepamandates_create(
    app_id: int = Path(..., alias='appId'),
    customer_organization_id: Optional[int] = None,
    customer_person_id: Optional[int] = None,
    old_mandate_id: Optional[int] = None,
    mandate_id: str = ...,
    signed_at: datetime = ...,
    electronic_signature: Optional[str] = None,
    customer_name: Optional[str] = None,
    iban: str = ...,
    bic: str = ...,
    is_first: Optional[bool] = None,
):
    """
    Create a SEPAMandate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/sepamandates/credittransfer',
    tags=['accounting_export_management', 'sepa_payment_operations'],
    security=[],
)
def app_payments_sepacredittransfer_preview(
    app_id: int = Path(..., alias='appId'), ids: Ids = ...
):
    """
    Preview sepa credit transfer file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/sepamandates/credittransfer',
    tags=['payments_management', 'sepa_payment_operations'],
    security=[],
)
def app_payments_sepacredittransfer_download(
    app_id: int = Path(..., alias='appId'),
    ids: Ids = ...,
    amounts: Optional[Amounts] = None,
    debtor_name: Optional[str] = None,
    debtor_iban: Optional[str] = None,
    debtor_bic: Optional[str] = None,
    btch_bookg: Optional[int] = Query(None, alias='btchBookg'),
):
    """
    Preview sepa credit transfer file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/sepamandates/directdebit',
    tags=['invoice_management', 'sepa_payment_operations'],
    security=[],
)
def app_payments_sepadirectdebit_preview(
    app_id: int = Path(..., alias='appId'), invoices_ids: InvoicesIds = ...
):
    """
    Preview sepa direct debit file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/sepamandates/directdebit',
    tags=['sepa_payment_operations', 'sepa_mandate_operations', 'payments_management'],
    security=[],
)
def app_payments_sepadirectdebit_download(
    app_id: int = Path(..., alias='appId'),
    invoices_ids: InvoicesIds = ...,
    amounts: Optional[Amounts] = None,
    creditor_name: Optional[str] = None,
    creditor_iban: Optional[str] = None,
    creditor_bic: Optional[str] = None,
    creditor_ics: Optional[str] = None,
    date: Optional[datetime] = None,
):
    """
    Download sepa direct debit file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/sepamandates/{id}', tags=['sepa_mandate_operations'], security=[]
)
def app_payments_sepamandates_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a SEPAMandate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/sepamandates/{id}', tags=['sepa_mandate_operations'], security=[]
)
def app_payments_sepamandates_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a SEPAMandate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/sepamandates/{id}',
    tags=['sepa_mandate_operations', 'payments_management'],
    security=[],
)
def app_payments_sepamandates_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    customer_organization_id: Optional[int] = None,
    customer_person_id: Optional[int] = None,
    old_mandate_id: Optional[int] = None,
    mandate_id: Optional[str] = None,
    signed_at: Optional[datetime] = None,
    electronic_signature: Optional[str] = None,
    customer_name: Optional[str] = None,
    iban: Optional[str] = None,
    bic: Optional[str] = None,
    is_first: Optional[bool] = None,
):
    """
    Update a SEPAMandate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/services/stripe/webhook',
    tags=['webhook_management', 'app_health_check'],
)
def app_services_stripe_webhook_ping(app_id: int = Path(..., alias='appId')):
    """
    Ping Stripe webhook endpoint
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/services/stripe/webhook', tags=['webhook_management'])
def app_services_stripe_webhook_handle(app_id: int = Path(..., alias='appId')):
    """
    Webhook for Stripe
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/apps/{appId}/services/yousign/webhook', tags=['webhook_management'])
def app_services_yousign_webhook_handle(app_id: int = Path(..., alias='appId')):
    """
    Webhook for Yousign
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/settings',
    description=""" Get a configuration variable by key """,
    tags=['app_configuration_management'],
    security=[],
)
def app_settings_get(app_id: int = Path(..., alias='appId'), key: Optional[str] = None):
    """
    Get app config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/settings',
    description=""" General settings of an app. Can be modified in app """,
    tags=['app_configuration_management', 'app_management'],
    security=[],
)
def app_settings_update(
    app_id: int = Path(..., alias='appId'),
    settings: Optional[Settings] = None,
    key: Optional[str] = None,
    value: Optional[str] = None,
):
    """
    Update app config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/signature',
    description=""" Create a new signature """,
    tags=['document_signature_management', 'app_invitations_management'],
    security=[],
)
def app_documents_sales_signature_create(
    app_id: int = Path(..., alias='appId'),
    document_id: int = Query(..., alias='documentId'),
    email: str = ...,
    firstname: str = ...,
    lastname: str = ...,
    phone: str = ...,
):
    """
    Create a signature
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/statistics/charts/{type}',
    tags=['sales_statistics', 'app_statistics_and_templates'],
    security=[],
)
def app_statistics_charts_get(
    app_id: int = Path(..., alias='appId'),
    type: str = ...,
    count: Optional[int] = None,
    period: Optional[Period] = None,
    start_at: Optional[datetime] = None,
    object: Optional[Object] = None,
    object_property: Optional[str] = None,
    calcul: Optional[Calcul] = None,
    methods: Optional[Methods] = None,
    object_date_property: Optional[str] = None,
    group_by: Optional[GroupBy] = None,
    group_by_object_name: Optional[str] = None,
    exclude_keys: Optional[ExcludeKeys] = None,
    search: Optional[str] = None,
    filters: Optional[Filters30] = None,
    show_details: Optional[bool] = None,
):
    """
    Obtain statistics about sales
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/statistics/timetable/purchases',
    tags=['purchase_management', 'sales_statistics'],
    security=[],
)
def app_statistics_timetable_purchases(
    app_id: int = Path(..., alias='appId'),
    detailed: Optional[bool] = False,
    groups: Optional[
        Groups
    ] = '[ [-730, -30], [-30, -1], [-1, 7], [7, 15], [15, 30], [30, 730] ]',
):
    """
    Obtain statistics about timetable purchases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/statistics/timetable/sales',
    tags=['sales_statistics', 'invoice_management', 'app_statistics_and_templates'],
    security=[],
)
def app_statistics_timetable_sales(
    app_id: int = Path(..., alias='appId'),
    detailed: Optional[bool] = False,
    groups: Optional[
        Groups
    ] = '[ [-730, -30], [-30, -1], [-1, 7], [7, 15], [15, 30], [30, 730] ]',
):
    """
    Obtain statistics about sales
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/statistics/vat',
    tags=[
        'app_accounting_entries_management',
        'sales_statistics',
        'app_statistics_and_templates',
    ],
    security=[],
)
def app_statistics_vat_get(
    app_id: int = Path(..., alias='appId'),
    detailed: Optional[bool] = False,
    start_at: Optional[datetime] = 'now',
    period: Optional[Period2] = None,
    end_at: Optional[datetime] = None,
):
    """
    Obtain statistics about vat
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/anchordate',
    tags=['app_management', 'app_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_anchordate(app_id: int = Path(..., alias='appId')):
    """
    Update anchor date
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/subscription/checkout_add_source',
    tags=['payments_management', 'payment_reconciliation'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_checkout_add_source(app_id: int = Path(..., alias='appId')):
    """
    Get payment link to Stripe Checkout
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/coupon',
    tags=['app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_coupon(app_id: int = Path(..., alias='appId'), code: str = ...):
    """
    Add coupon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/extend_trial',
    tags=['app_subscription_management', 'subscription_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_extend_trial(app_id: int = Path(..., alias='appId')):
    """
    Extend trial period
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/extra/{stripe_plan}',
    tags=['subscription_management', 'app_subscription_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_extra_enable(
    app_id: int = Path(..., alias='appId'), stripe_plan: str = ...
):
    """
    Enable plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/pay_all',
    tags=['invoice_management', 'payments_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_pay_all(app_id: int = Path(..., alias='appId')):
    """
    Pay all due invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/subscription/plan',
    tags=['app_subscription_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_end(app_id: int = Path(..., alias='appId')):
    """
    End current plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/subscription/plan',
    tags=['app_subscription_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_get(app_id: int = Path(..., alias='appId')):
    """
    Get current plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/subscription/plans',
    tags=['app_management', 'subscription_management', 'app_subscription_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_list(app_id: int = Path(..., alias='appId')):
    """
    Get plans
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/subscription/plans/{stripe_plan}',
    tags=['subscription_management', 'app_subscription_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_upcoming(
    app_id: int = Path(..., alias='appId'),
    stripe_plan: str = ...,
    stripe_coupon: Optional[str] = None,
):
    """
    Simulate a plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/plans/{stripe_plan}',
    tags=['subscription_management', 'app_subscription_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_pay(
    app_id: int = Path(..., alias='appId'),
    stripe_plan: str = ...,
    stripe_source: Optional[str] = None,
    stripe_coupon: Optional[str] = None,
):
    """
    Change plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/subscription/plans/{stripe_plan}/checkout',
    tags=['payments_management', 'subscription_management', 'app_payment_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_checkout(
    app_id: int = Path(..., alias='appId'),
    stripe_plan: str = ...,
    stripe_coupon: Optional[str] = None,
):
    """
    Get payment link to Stripe Checkout
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/subscription/source',
    tags=['payments_management', 'sepa_payment_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_remove_source(
    app_id: int = Path(..., alias='appId'), stripe_source: str = ...
):
    """
    Remove creditcard or sepadebit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/source',
    tags=['payments_management', 'sepa_payment_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_add_source(
    app_id: int = Path(..., alias='appId'), stripe_source: str = ...
):
    """
    Add creditcard or sepadebit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/subscription/source/default',
    tags=['app_configuration_management', 'payments_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def app_subscription_set_default(
    app_id: int = Path(..., alias='appId'), stripe_source: str = ...
):
    """
    Change default source
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/apps/{appId}/tags', tags=['app_management'], security=[])
def app_statistics_tags_get(
    app_id: int = Path(..., alias='appId'), object: Optional[Object2] = None
):
    """
    Get all existants tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/templates',
    description=""" Get all templates """,
    tags=['app_statistics_and_templates', 'app_management'],
    security=[],
)
def app_settings_templates_list(app_id: int = Path(..., alias='appId')):
    """
    Get templates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/templates',
    description=""" Create a template """,
    tags=['app_management'],
    security=[],
)
def app_settings_templates_create(app_id: int = Path(..., alias='appId')):
    """
    Create a template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/templates/batch',
    description=""" Create multiple templates """,
    tags=['app_statistics_and_templates', 'app_management'],
    security=[],
)
def app_settings_templates_batch(
    app_id: int = Path(..., alias='appId'), data: Data9 = ...
):
    """
    Create multiple templates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/templates/default',
    description=""" Get the default template """,
    tags=['app_management', 'app_statistics_and_templates'],
    security=[],
)
def app_settings_templates_default_template(app_id: int = Path(..., alias='appId')):
    """
    Get default template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/templates/{id}',
    description=""" Get a template """,
    tags=['app_statistics_and_templates', 'app_management'],
    security=[],
)
def app_settings_templates_get(app_id: int = Path(..., alias='appId'), id: str = ...):
    """
    Get a template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/templates/{id}',
    description=""" Update a template """,
    tags=[
        'app_statistics_and_templates',
        'app_configuration_management',
        'sales_document_model_management',
    ],
    security=[],
)
def app_settings_templates_update(
    app_id: int = Path(..., alias='appId'), id: str = ...
):
    """
    Update a template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/transactions/',
    tags=['app_cashflow_transactions', 'payments_management'],
    security=[],
)
def app_cashflow_transactions_list(
    app_id: int = Path(..., alias='appId'),
    offset: Optional[conint(ge=0)] = None,
    limit: Optional[conint(ge=1, le=10000)] = 10,
    search: Optional[str] = None,
    filters: Optional[Filters31] = None,
    order: Optional[Order27] = None,
):
    """
    List Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/transactions/',
    tags=[
        'app_cashflow_management',
        'app_cashflow_transactions',
        'payments_management',
    ],
    security=[],
)
def app_cashflow_transactions_create(
    app_id: int = Path(..., alias='appId'),
    contact_organization_id: Optional[int] = None,
    contact_person_id: Optional[int] = None,
    account_id: Optional[int] = None,
    cashflow_source_id: int = ...,
    contact_name: Optional[str] = None,
    amount: int = ...,
    method: Optional[Method] = None,
    received_at: datetime = ...,
    label: Optional[str] = None,
    details: Optional[str] = None,
):
    """
    Create a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/transactions/batch',
    tags=['app_cashflow_transactions', 'payments_management'],
    security=[],
)
def app_cashflow_transactions_batch(
    app_id: int = Path(..., alias='appId'), data: Data10 = ...
):
    """
    Create multiple transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/transactions/{id}',
    tags=['app_cashflow_transactions', 'app_accounting_entries_management'],
    security=[],
)
def app_cashflow_transactions_delete(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Remove a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/transactions/{id}',
    tags=['app_cashflow_transactions', 'payments_management'],
    security=[],
)
def app_cashflow_transactions_get(
    app_id: int = Path(..., alias='appId'), id: int = ...
):
    """
    Get a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/transactions/{id}',
    tags=[
        'app_cashflow_management',
        'app_cashflow_transactions',
        'payments_management',
    ],
    security=[],
)
def app_cashflow_transactions_update(
    app_id: int = Path(..., alias='appId'),
    id: int = ...,
    contact_organization_id: Optional[int] = None,
    contact_person_id: Optional[int] = None,
    account_id: Optional[int] = None,
    cashflow_source_id: Optional[int] = None,
    contact_name: Optional[str] = None,
    amount: Optional[int] = None,
    method: Optional[Method] = None,
    received_at: Optional[datetime] = None,
    label: Optional[str] = None,
    details: Optional[str] = None,
):
    """
    Update a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/transactions/{id}/attach',
    tags=['app_attachment_management'],
    security=[],
)
def app_cashflow_transactions_detach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file_id: Optional[int] = None
):
    """
    Detach a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/transactions/{id}/attach',
    tags=['app_attachment_management', 'app_file_attachment'],
    security=[],
)
def app_cashflow_transactions_attach(
    app_id: int = Path(..., alias='appId'), id: int = ..., file: Optional[bytes] = None
):
    """
    Attach a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/urssaf/auth',
    tags=['user_authentication', 'app_payments_urssaf_management'],
    security=[],
)
def app_payments_urssaftiers_auth(
    app_id: int = Path(..., alias='appId'),
    client_id: str = ...,
    client_secret: str = ...,
):
    """
    Login URSSAF
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/urssaf/payment',
    tags=['payments_management', 'invoice_management'],
    security=[],
)
def app_payments_urssaftiers_get_status(
    app_id: int = Path(..., alias='appId'), invoices_ids: InvoicesIds = ...
):
    """
    Get status of a payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/urssaf/payment',
    tags=['app_payments_urssaf_management', 'payments_management'],
    security=[],
)
def app_payments_urssaftiers_send_payments(app_id: int = Path(..., alias='appId')):
    """
    Send URSSAF request payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/urssaf/preview',
    tags=['app_payments_urssaf_management', 'payments_management'],
    security=[],
)
def app_payments_urssaftiers_preview(
    app_id: int = Path(..., alias='appId'), type: Type52 = ..., ids: Ids = ...
):
    """
    Preview URSSAF request payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/urssaf/register_customer',
    tags=[
        'app_payments_urssaf_management',
        'sepa_mandate_operations',
        'user_account_management',
    ],
    security=[],
)
def app_payments_urssaftiers_register_customer(app_id: int = Path(..., alias='appId')):
    """
    Register a person to URSSAF and create him a mandate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/changepassword',
    description=""" Change password by email forgotten_password_token """,
    tags=['user_account_management', 'user_authentication'],
    security=[],
)
def auth_changepassword(forgotten_password_token: str, password: str = ...):
    """
    Change password
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/login',
    description=""" User login by email and password. Used only on Sinao API. CloudAccounting API needs a different API key """,
    tags=['user_authentication', 'user_account_management'],
)
def auth_login(email: EmailStr, password: str = ...):
    """
    Login
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/logout',
    description=""" Log the user out (Invalidate the token) """,
    tags=['user_account_management', 'user_authentication'],
    security=[],
)
def auth_logout():
    """
    Logout
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me',
    description=""" Get current logged user, as `User` object """,
    tags=['user_account_management', 'user_authentication'],
    security=[],
)
def account_get():
    """
    Get current user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me',
    description=""" Update current user informations """,
    tags=['user_account_management'],
    security=[],
)
def account_update(
    civility: Optional[str] = None,
    firstname: Optional[str] = None,
    lastname: Optional[str] = None,
    password: Optional[str] = None,
    email: Optional[EmailStr] = None,
    image: Optional[bytes] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Update current user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/ping', tags=['app_health_check'])
def auth_ping():
    """
    Ping server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/refresh',
    description=""" Refresh token without relogin """,
    tags=['user_authentication', 'app_configuration_management'],
    security=[],
)
def auth_refresh():
    """
    Refresh a token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/register',
    description=""" Create a new `User` from the registration form. The user will be created without an application or access, there is nothing he can do without another step such as creating an application or inviting access """,
    tags=['user_account_management', 'user_authentication'],
    security=[],
)
def account_create(
    email: EmailStr,
    password: str = ...,
    cgu: bool = ...,
    firstname: Optional[str] = None,
    lastname: Optional[str] = None,
    metadata: Optional[Metadata] = None,
):
    """
    Create an User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sendpassword',
    description=""" Send a forgotten_password_token by email to recover password """,
    tags=['user_account_management', 'user_authentication'],
    security=[],
)
def auth_sendpassword(email: EmailStr):
    """
    Password recover by email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/services/collector', tags=['purchase_management', 'purchase_operations'])
def admin_purchase_collector_push(
    app_identifiant: str, collector_key: str = ..., invoice: bytes = ...
):
    """
    Push to purchase collector
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/services/vies/{siren}', tags=['vies_data_retrieval'])
def services_vies_get(siren: str):
    """
    Get VIES database informations from SIREN
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
